# -*- coding: utf-8 -*-
"""estructuras_sem_04.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZCxDUkh9hUP_ThliryhP8rKBzayoDCLr

##Ejercicio 1: Implementación Básica
Implementa una lista enlazada simple que pueda realizar operaciones de
inserción al principio, al final y en una posición específica, y eliminar
"""

class Node:
    def __init__(self, data=None):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    def insert_at_beginning(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node

    def insert_at_end(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
            return
        current = self.head
        while current.next:
            current = current.next
        current.next = new_node

    def insert_at_position(self, position, data):
        if position <= 0:
            print("Position should be greater than 0")
            return
        new_node = Node(data)
        if position == 1:
            new_node.next = self.head
            self.head = new_node
        else:
            current = self.head
            while True:
                if not current:
                    print("Position out of range")
                    return
                position -= 1
                if position == 1:
                    new_node.next = current.next
                    current.next = new_node
                    break
                current = current.next

    def delete_at_position(self, position):
        if position <= 0:
            print("Position should be greater than 0")
            return
        if not self.head:
            print("List is empty")
            return
        current = self.head
        if position == 1:
            self.head = current.next
            current = None
            return
        while True:
            if not current.next:
                print("Position out of range")
                return
            position -= 1
            if position == 1:
                current.next = current.next.next
                return
            current = current.next

    def print_list(self):
        current = self.head
        while current:
            print(current.data, end=" ")
            current = current.next
        print()


ll = LinkedList()
ll.insert_at_end(1)
ll.insert_at_end(2)
ll.insert_at_end(3)
ll.insert_at_end(4)
ll.insert_at_end(5)
ll.print_list()

ll.insert_at_beginning(0)
ll.print_list()

ll.insert_at_position(4, 3.5)
ll.print_list()

ll.delete_at_position(3)
ll.print_list()

#complejidad de tiempo: O(1)
#complejidad de espacio: O(n)

"""##Ejercicio 2: Búsqueda en Lista Enlazada
Escribe una función que busque un elemento en una lista enlazada y devuelva
True si se encuentra y False si no.
"""

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    def insert_at_end(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node

    def search(self, data):
        current = self.head
        while current:
            if current.data == data:
                return True
            current = current.next
        return False

    def print_list(self):
        current = self.head
        while current:
            print(current.data, end=" ")
            current = current.next
        print()

ll = LinkedList()
ll.insert_at_end(1)
ll.insert_at_end(2)
ll.insert_at_end(3)
ll.insert_at_end(4)
ll.insert_at_end(5)
ll.print_list()

print(ll.search(3)) # Output: True
print(ll.search(6)) # Output: False

#complejidad de tiempo: O(n)
#complejidad de espacio: O(1)

"""##Ejercicio 3: Inversión de Lista
Escribe una función que invierta una lista enlazada. Es decir, el primer nodo
se convierte en el último, el segundo se convierte en el penúltimo, y así
sucesivamente.
"""

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    def insert_at_end(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node

    def print_list(self):
        current = self.head
        while current:
            print(current.data, end=" ")
            current = current.next
        print()

    def reverse(self):
        prev = None
        current = self.head
        while current:
            next_node = current.next
            current.next = prev
            prev = current
            current = next_node
        self.head = prev

ll = LinkedList()
ll.insert_at_end(1)
ll.insert_at_end(2)
ll.insert_at_end(3)
ll.insert_at_end(4)
ll.insert_at_end(5)
ll.print_list()

ll.reverse()
ll.print_list()

#complejidad de tiempo: O(n)
#complejidad de espacio: O(1)

"""##Ejercicio 4: Eliminaciön de Duplicados
Escribe una funciön que elimine los elementos duplicados de una lista enlazada
sin util izar estructuras de datos adicionales.
"""

class Node:
    def __init__(self, data=None):
        self.data = data
        self.next = None

def delete_duplicates(head):
    if head is None:
        return None

    current = head
    next_node = current.next

    while next_node is not None:
        if current.data == next_node.data:
            current.next = next_node.next
            next_node = current.next
        else:
            current = next_node
            next_node = current.next

    return head
# crear lista enlazada
head = Node(1)
head.next = Node(2)
head.next.next = Node(2)
head.next.next.next = Node(3)
head.next.next.next.next = Node(3)

# imprimir lista enlazada original
print("Lista enlazada original:")
current = head
while current is not None:
    print(current.data, end=" ")
    current = current.next
print()

# eliminar duplicados y imprimir lista enlazada resultante
head = delete_duplicates(head)
print("Lista enlazada resultante:")
current = head
while current is not None:
    print(current.data, end=" ")
    current = current.next
print()

#complejidad de tiempo: O(n)
#complejidad de espacio: O(1)

"""##Ejercicio 5: Concatenación de Listas
Escribe una función que tome dos listas enlazadas y las concatene para formar
una lista más larga.
"""

class Node:
    def __init__(self, data=None):
        self.data = data
        self.next = None

def print_list(head):
    while head is not None:
        print(head.data, end=" ")
        head = head.next
    print()

def concat_lists(head1, head2):
    if head1 is None:
        return head2
    if head2 is None:
        return head1

    # recorrer la lista enlazada 1 hasta el final
    current = head1
    while current.next is not None:
        current = current.next

    # unir la lista enlazada 1 con la lista enlazada 2
    current.next = head2
    return head1

# ejemplo de uso
head1 = Node(1)
head1.next = Node(2)
head1.next.next = Node(3)

head2 = Node(4)
head2.next = Node(5)
head2.next.next = Node(6)

print("Lista 1:")
print_list(head1)

print("Lista 2:")
print_list(head2)

result = concat_lists(head1, head2)

print("Lista resultante:")
print_list(result)

#complejidad de tiempo: O(n)
#complejidad de espacio: O(n)

"""##Ejercicio 6: Detectar Ciclo
Escribe una función que detecte si una lista enlazada tiene un ciclo, es decir,
si algún nodo apunta a un nodo previamente visitado.
"""

class Node:
    def __init__(self, data=None):
        self.data = data
        self.next = None

def has_cycle(head):
    slow = fast = head

    while fast is not None and fast.next is not None:
        slow = slow.next
        fast = fast.next.next

        if slow == fast:
            return True

    return False

# ejemplo de uso
head = Node(1)
head.next = Node(2)
head.next.next = Node(3)
head.next.next.next = head

print("Ciclo detectado" if has_cycle(head) else "No hay ciclo")


head = Node(66)
head.next = Node(1)
head.next.next = Node(100)
head.next.next.next = Node(200)
head.next.next.next.next = Node(300)
head.next.next.next.next.next = head.next.next.next

print("Ciclo detectado" if has_cycle(head) else "No hay ciclo")
#complejidad de tiempo: O(n)
#complejidad de espacio: O(1)

"""##Ejercicio 7: Lista Palíndromo
Escribe una función que determine si una lista enlazada es un palíndromo, es
decir, si se lee igual en ambas direcciones.
"""

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def is_palindrome(head):
    slow = fast = head
    stack = []

    # Inverted second half
    while fast and fast.next:
        stack.append(slow.data)
        slow = slow.next
        fast = fast.next.next

    # Handling the case when the list has an odd number of nodes
    if fast:
        stack.append(slow.data)

    # Checking for palindrome property
    while slow:
        if stack.pop() != slow.data:
            return False
        slow = slow.next

    return True

head = Node(66)
head.next = Node(1)
head.next.next = Node(100)
head.next.next.next = Node(200)
head.next.next.next.next = Node(300)

print("Es palindromo" if is_palindrome(head) else "No es palindromo")

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def is_palindrome(head):
    # If the list is empty or has only one element, it is a palindrome
    if head is None or head.next is None:
        return True

    # Find the mid point of the list
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

    # Reverse the second half of the list
    second_half = reverse(slow)

    # Compare the elements in the first half and the reversed second half
    while second_half and second_half.data == head.data:
        second_half = second_half.next
        head = head.next

    # If we reached the end of the second half, it means the list is a palindrome
    return second_half is None

def reverse(head):
    prev = None
    while head:
        next_node = head.next
        head.next = prev
        prev = head
        head = next_node
    return prev

head = Node(66)
head.next = Node(1)
head.next.next = Node(100)
head.next.next.next = Node(200)
head.next.next.next.next = Node(300)

print("Es palindromo" if is_palindrome(head) else "No es palindromo")

#complejidad de tiempo: O(n)
#complejidad de espacio: O(1)

"""##Ejercicio 8: Eliminación de Nodos
Escribe una función que elimine todos los nodos de una lista enlazada que
contengan un valor especifico.
"""

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def delete_nodes(head, value):
    if head is None:
        return None

    # Create a new node as a placeholder for the head
    dummy_head = Node(0)
    dummy_head.next = head

    # Use two pointers to traverse the list
    prev = dummy_head
    curr = head

    while curr:
        if curr.data == value:
            prev.next = curr.next
        else:
            prev = curr
        curr = curr.next

    return dummy_head.next

head = Node(1)
head.next = Node(2)
head.next.next = Node(3)
head.next.next.next = Node(2)
head.next.next.next.next = Node(2)
head.next.next.next.next.next = Node(4)

head = delete_nodes(head, 2)

# Print the remaining nodes in the list
while head:
    print(head.data, end=" ")
    head = head.next


#complejidad de tiempo: O(n)
#complejidad de espacio: O(1)

"""##Ejercicio 9: Inserción Ordenada
Escribe una función que inserte un nuevo nodo en una lista enlazada de manera
ordenada, manteniendo Ia lista ordenada en todo momento.
"""

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def insert_sorted(head, new_data):
    if head is None:
        return Node(new_data)

    # Create a new node as a placeholder for the head
    dummy_head = Node(0)
    dummy_head.next = head

    # Use two pointers to find the position to insert the new node
    prev = dummy_head
    curr = head

    while curr and curr.data < new_data:
        prev = curr
        curr = curr.next

    # Insert the new node
    new_node = Node(new_data)
    new_node.next = curr
    prev.next = new_node

    return dummy_head.next

head = Node(1)
head.next = Node(3)
head.next.next = Node(5)

head = insert_sorted(head, 2)
head = insert_sorted(head, 4)

# Print the nodes in the modified list
while head:
    print(head.data, end=" ")
    head = head.next

#complejidad de tiempo: O(n)
#complejidad de espacio: O(1)



"""##Ejercicio 10: Longitud de Lista
Escribe una función que calcule Ia longitud de una lista enlazada.
"""

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def length(head):
    count = 0
    temp = head

    while temp:
        count += 1
        temp = temp.next

    return count

head = Node(1)
head.next = Node(3)
head.next.next = Node(5)

print("Longitud de la lista:", length(head))
#complejidad de tiempo: O(n)
#complejidad de espacio: O(1)

"""##Ejercicio !!: Implementación Avanzada
Implementa una lista enlazada doble y una lista enlazada circular simple que
pueda realizar operaciones de inserción y eliminar elementos.
"""

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None

class LinkedList:
    def __init__(self):
        self.head = None
class LinkedList:
    def __init__(self):
        self.head = None

    def insert(self, data):
        if not self.head:
            self.head = Node(data)
            self.head.prev = self.head
            self.head.next = self.head
        else:
            new_node = Node(data)
            cur = self.head
            while cur.next != self.head:
                cur = cur.next
            cur.next = new_node
            new_node.prev = cur
            new_node.next = self.head
            self.head.prev = new_node

    def delete(self, data):
        if not self.head:
            return
        cur = self.head
        while cur:
            if cur.data == data:
                if cur.next == self.head:
                    self.head = None
                    return
                cur.prev.next = cur.next
                cur.next.prev = cur.prev
                if cur == self.head:
                    self.head = cur.next
                return
            cur = cur.next

#complejidad de tiempo: O(n)
#complejidad de espacio: O(n)