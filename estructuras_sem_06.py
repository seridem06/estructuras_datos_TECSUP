# -*- coding: utf-8 -*-
"""estructuras_sem_06.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1E563F5cnO-bNNWZ1D10JZEqdhoABRV-a

##Ejercicio 1: Implementación de una cola
Crea una cola utilizando una estructura de arreglo o una lista enlazada. Luego,
crea funciones para agregar y quitar elementos de Ia cola. Asegúrate de manejar
el caso de una cola vacía y de implementar una función para verificar si Ia
cola está vacía.
"""

class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return len(self.items) == 0

    def enqueue(self, item):
        self.items.append(item)

    def dequeue(self):
        if self.is_empty():
            raise Exception("Queue is empty")
        return self.items.pop(0)

# Testing the Queue
queue = Queue()
print(f"Queue is empty: {queue.is_empty()}")

queue.enqueue(1)
queue.enqueue(2)
queue.enqueue(3)
print(f"Queue after enqueue operations: {queue.items}")

dequeued_item = queue.dequeue()
print(f"Dequeued item: {dequeued_item}")
print(f"Queue after dequeue operation: {queue.items}")

#COMPLEJIDAD DE TIEMPO: O(1)
#COMPLEJIDAD DE ESPACIO: O(n)

"""##Ejercicio 2: Simulación de Fila en un Supermercado
Implementen una simulación de una fila en un supermercado utilizando una cola.
Los clientes se agregarán a Ia cola cuando lleguen al supermercado y se
atenderán en orden. Los estudiantes pueden agregar operaciones de encolar y
desencolar para simular el flujo de clientes.
"""

import random

class SupermarketQueue:
    def __init__(self):
        self.queue = Queue()

    def simulate_customer_arrival(self):
        new_customer = random.randint(1, 5)
        for _ in range(new_customer):
            self.queue.enqueue(f"Customer {random.randint(1000, 9999)}")
        return new_customer

    def simulate_customer_checkout(self):
        try:
            checked_out_customer = self.queue.dequeue()
            return checked_out_customer
        except Exception as e:
            return str(e)

    def get_queue_status(self):
        return self.queue.items

# Testing the SupermarketQueue
supermarket_queue = SupermarketQueue()

# Simulate customer arrivals and checkouts
for _ in range(10):
    num_new_customers = supermarket_queue.simulate_customer_arrival()
    print(f"{num_new_customers} new customer(s) arrived")

    if num_new_customers > 0:
        checked_out_customer = supermarket_queue.simulate_customer_checkout()
        print(f"Checked out customer: {checked_out_customer}")

print(f"Queue status: {supermarket_queue.get_queue_status()}")

#COMPLEJIDAD DE TIEMPO: O(1)
#COMPLEJIDAD DE ESPACIO: O(n)

"""##Ejercicio 3: Procesamiento de Tareas en una Cola
Desarolle un programa que simule el procesamiento de tareas en una cola. Cada
tarea tiene un tiempo estimado para completarse. Los estudiantes pueden
implementar operaciones para agregar tareas a Ia cola, procesarlas en orden y
calcular el tiempo total necesario para completar todas las tareas.
"""

class Tarea:
    def __init__(self, tiempo_estimado, prioridad):
        self.tiempo_estimado = tiempo_estimado
        self.prioridad = prioridad

class ColaTareas:
    def __init__(self):
        self.cola = []

    def agregar_tarea(self, tarea):
        self.cola.append(tarea)

    def procesar_tareas(self):
        self.cola.sort(key=lambda x: (x.prioridad, x.tiempo_estimado))
        total_tiempo = 0
        for tarea in self.cola:
            total_tiempo += tarea.tiempo_estimado
        return total_tiempo
cola_tareas = ColaTareas()
cola_tareas.agregar_tarea(Tarea(10, 1))
cola_tareas.agregar_tarea(Tarea(5, 2))
cola_tareas.agregar_tarea(Tarea(15, 1))
total_tiempo = cola_tareas.procesar_tareas()
print("El tiempo total necesario para completar todas las tareas es:", total_tiempo)

#COMPLEJIDAD DE TIEMPO: O(n log n)
#COMPLEJIDAD DE ESPACIO: O(n)

"""##Ejercicio 4: Cola de Mensajes
Simula una
mensajes a
recepción.
desencolar
cola de mensajes en
otros usuarios, que
en Redes Sociales
una red social. Los usuarios pueden enviar
se encolarán y se mostrarán en orden de
Los estudiantes pueden implementar operaciones de encolar,
y mostrar los mensajes en Ia cola.
"""

class Mensaje:
    def __init__(self, texto, usuario):
        self.texto = texto
        self.usuario = usuario

class ColaMensajes:
    def __init__(self):
        self.cola = []

    def encolar_mensaje(self, mensaje):
        self.cola.append(mensaje)

    def desencolar_mensajes(self):
        self.cola.sort(key=lambda x: x.usuario)
        mensajes_usuario = {}
        for mensaje in self.cola:
            if mensaje.usuario not in mensajes_usuario:
                mensajes_usuario[mensaje.usuario] = []
            mensajes_usuario[mensaje.usuario].append(mensaje.texto)
        return mensajes_usuario

cola_mensajes = ColaMensajes()
cola_mensajes.encolar_mensaje(Mensaje("Hola, usuario 2!", "usuario 1"))
cola_mensajes.encolar_mensaje(Mensaje("Hola, usuario 1!", "usuario 2"))
cola_mensajes.encolar_mensaje(Mensaje("Adios, usuario 2!", "usuario 1"))
mensajes_ordenados = cola_mensajes.desencolar_mensajes()
for usuario, mensajes in mensajes_ordenados.items():
    print(f"Mensajes para {usuario}:")
    for mensaje in mensajes:
        print(f"- {mensaje}")


#COMPLEJIDAD DE TIEMPO: O(n log n)
#COMPLEJIDAD DE ESPACIO: O(n)

"""##Ejercicio 5: Procesamiento de Ordenes en un Restaurante
Pide a los estudiantes que simulen el procesamiento de órdenes en un
restaurante utilizando una cola. Los pedidos de comida se agregan a Ia cola y
se atienden en orden. Los estudiantes pueden implementar operaciones de
encolar, desencolar y calcular el tiempo promedio de espera para las órdenes.
"""

class Mensaje:
    def __init__(self, texto, usuario):
        self.texto = texto
        self.usuario = usuario

class ColaMensajes:
    def __init__(self):
        self.cola = []

    def encolar_mensaje(self, mensaje):
        self.cola.append(mensaje)

    def desencolar_mensajes(self):
        self.cola.sort(key=lambda x: x.usuario)
        mensajes_usuario = {}
        for mensaje in self.cola:
            if mensaje.usuario not in mensajes_usuario:
                mensajes_usuario[mensaje.usuario] = []
            mensajes_usuario[mensaje.usuario].append(mensaje.texto)
        return mensajes_usuario


cola_mensajes = ColaMensajes()
cola_mensajes.encolar_mensaje(Mensaje("Hola, usuario 2!", "usuario 1"))
cola_mensajes.encolar_mensaje(Mensaje("Hola, usuario 1!", "usuario 2"))
cola_mensajes.encolar_mensaje(Mensaje("Adios, usuario 2!", "usuario 1"))
mensajes_ordenados = cola_mensajes.desencolar_mensajes()
for usuario, mensajes in mensajes_ordenados.items():
    print(f"Mensajes para {usuario}:")
    for mensaje in mensajes:
        print(f"- {mensaje}")

#COMPLEJIDAD DE TIEMPO: O(n log n)
#COMPLEJIDAD DE ESPACIO: O(n)

"""##Ejercicio 6: Cola de Impresión
Implemente una cola de impresión. Cada tarea de impresión se agrega a Ia cola y
se imprime en orden. Los estudiantes pueden simular el tiempo de impresión y
calcular el tiempo total necesario para imprimir todas las tareas.
"""


class TareaImpresion:
    def __init__(self, tiempo_impresion):
        self.tiempo_impresion = tiempo_impresion

class ColaImpresion:
    def __init__(self):
        self.cola = []

    def agregar_tarea(self, tarea):
        self.cola.append(tarea)

    def imprimir_resultados(self):
        tiempo_total = 0
        for tarea in self.cola:
            tiempo_total += tarea.tiempo_impresion
            print(f"Tarea {tarea.tiempo_impresion} minutos impresa.")
        print(f"Tiempo total de impresión: {tiempo_total} minutos.")

cola = ColaImpresion()

cola.agregar_tarea(TareaImpresion(10))
cola.agregar_tarea(TareaImpresion(20))
cola.agregar_tarea(TareaImpresion(30))

cola.imprimir_resultados()

#COMPLEJIDAD DE TIEMPO: O(n)
#COMPLEJIDAD DE ESPACIO: O(n)

"""##Ejercicio 7: sistema de turnos en una  clinica

desarrolle un sistema de turnos en una clinica utlizando una cola
los pacientes llegan a la clinica y se les asigna un turno en la cola, lueog. los pacientes
 son atendidos en roden. los estudiantes pueden agregar operaciones de encolar, desencolar,  y calcular el tiempo promedio de espera para los pacientes
ccomplejidad de tiempo y complkejidad de espacio
"""

import queue

class Paciente:
    def __init__(self, nombre, tiempo_atencion):
        self.nombre = nombre
        self.tiempo_atencion = tiempo_atencion

class Clinica:
    def __init__(self):
        self.cola_pacientes = queue.Queue()

    def encolar(self, paciente):
        self.cola_pacientes.put(paciente)

    def desencolar(self):
        if not self.cola_pacientes.empty():
            return self.cola_pacientes.get()

    def tiempo_promedio_espera(self):
        total_tiempo_espera = 0
        total_pacientes = 0
        tiempo_actual = 0

        while not self.cola_pacientes.empty():
            paciente = self.cola_pacientes.get()
            total_tiempo_espera += tiempo_actual
            total_pacientes += 1
            tiempo_actual += paciente.tiempo_atencion

        return total_tiempo_espera / total_pacientes if total_pacientes > 0 else 0

def imprimir_resultados(clinica):
    print("Pacientes en la cola:")
    while not clinica.cola_pacientes.empty():
        paciente = clinica.cola_pacientes.get()
        print(f"- {paciente.nombre} ({paciente.tiempo_atencion} minutos)")

    print(f"Tiempo promedio de espera: {clinica.tiempo_promedio_espera()} minutos")


clinica = Clinica()
clinica.encolar(Paciente("Juan", 5))
clinica.encolar(Paciente("Ana", 3))
clinica.encolar(Paciente("Pedro", 10))

imprimir_resultados(clinica)

#COMPLEJIDAD DE TIEMPO: O(1)
#COMPLEJIDAD DE ESPACIO: O(n)

"""##Ejercicio 8: organizacion de eventos
cree un programa que organica la asistencias a un evento utilizando una cola.
los participantes se encolaran para ingresar a levento y luego se atenderan en orden
los estudiantes pueden implementar operaciones en encolar, desencolar y calcular al tiempo promedio
de espera para ingresar al evento.complejidad de tiempo y complejidad de espacio

"""

from collections import deque

class Evento:
    def __init__(self):
        self.cola = deque()
        self.espera_total = 0
        self.contador = 0

    def ingresar(self, estudiante):
        self.cola.append(estudiante)
        self.contador += 1

    def atender(self):
        if self.cola:
            estudiante = self.cola.popleft()
            self.espera_total += estudiante
            promedio = self.espera_total / self.contador
            return f"{estudiante} atendido. Tiempo promedio de espera: {promedio}"
        else:
            return "No hay nadie en la cola"

# Prueba del programa
evento = Evento()

evento.ingresar(10) # Ingresan 10 estudiantes
evento.ingresar(20)
evento.ingresar(30)

print(evento.atender()) # Se atiende al primer estudiante, tardó 10 minutos
print(evento.atender()) # Se atiende al segundo estudiante, tardó 20 minutos
print(evento.atender()) # Se atiende al tercer estudiante, tardó 30 minutos

"""##Ejercicio 9: organizacion de eventos

implementa una cola, utilizando dos pilas
complejidad de tiempo y complejidad de espacio
obtener resultados en python
"""

class MyQueue:
    def __init__(self):
        self.stack1 = []
        self.stack2 = []

    def enqueue(self, x):
        self.stack1.append(x)

    def dequeue(self):
        if not self.stack2:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        return self.stack2.pop()

    def isEmpty(self):
        return len(self.stack1) == 0 and len(self.stack2) == 0


# Ejemplo de uso
queue = MyQueue()
queue.enqueue(1)
queue.enqueue(2)
queue.enqueue(3)

print(queue.dequeue()) # Devuelve 1
print(queue.dequeue()) # Devuelve 2
print(queue.dequeue()) # Devuelve 3
print(queue.isEmpty()) # Devuelve True


#COMPLEJIDAD DE TIEMPO: O(1)
#COMPLEJIDAD DE ESPACIO: O(n)